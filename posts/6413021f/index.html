<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>How to Use Inline Assembly Language in C Code | 路双宁的博客</title><meta name="keywords" content="C,翻译,汇编"><meta name="author" content="路双宁"><meta name="copyright" content="路双宁"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="内核代码中经常会见到内联汇编的使用，读起来丈二和尚摸不着头脑，本文是对文章 *GCC-Inline-Assembly-HOWTO* 的翻译，希望可以帮助到学习内联汇编的人。">
<meta property="og:type" content="article">
<meta property="og:title" content="How to Use Inline Assembly Language in C Code">
<meta property="og:url" content="https://lushuangning.github.io/posts/6413021f/index.html">
<meta property="og:site_name" content="路双宁的博客">
<meta property="og:description" content="内核代码中经常会见到内联汇编的使用，读起来丈二和尚摸不着头脑，本文是对文章 *GCC-Inline-Assembly-HOWTO* 的翻译，希望可以帮助到学习内联汇编的人。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-04-01T12:33:56.000Z">
<meta property="article:modified_time" content="2024-12-26T05:09:44.166Z">
<meta property="article:author" content="路双宁">
<meta property="article:tag" content="C">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lushuangning.github.io/posts/6413021f/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.4.2',
  algolia: {"appId":"NT7VBMEHNU","apiKey":"db90b9537944fac58a60e68f42c776cf","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 路双宁","link":"链接: ","source":"来源: 路双宁的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"图灵,麦卡锡,明斯基,冯·诺依曼,伯纳斯·李,香农,肯·汤普森,林纳斯·托瓦兹","fontSize":"15px"},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2024-12-26 13:09:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'true'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><style type="text/css">#toggle-sidebar {bottom: 80px}</style><link rel="stylesheet" href="//at.alicdn.com/t/font_2149337_g9rq691k4pp.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><script src="https://cdn.jsdelivr.net/gh/lushuangning/live2d-widget@latest/"></script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">105</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">58</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9D%83%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">版权与协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E9%A6%88%E4%B8%8E%E6%9B%B4%E6%AD%A3"><span class="toc-number">1.2.</span> <span class="toc-text">反馈与更正</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%B8%A3%E8%B0%A2"><span class="toc-number">1.3.</span> <span class="toc-text">鸣谢</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">GCC 汇编语法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">基本内联</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">扩展内联汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.1.</span> <span class="toc-text">汇编程序模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">操作数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Clobber-%E5%88%97%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">Clobber 列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Volatile-%E2%80%A6"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 Volatile … ?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">关于约束</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.1.</span> <span class="toc-text">常用约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">约束修饰符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">一些实用的诀窍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">结束语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">参考</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">路双宁的博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 画廊</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">How to Use Inline Assembly Language in C Code</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-01T12:33:56.000Z" title="发表于 2022-04-01 20:33:56">2022-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-26T05:09:44.166Z" title="更新于 2024-12-26 13:09:44">2024-12-26</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>原文链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a></p>
<p>参考链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">How to Use Inline Assembly Language in C Code</a></p>
<p>虽然在其他地方看到过该文章的翻译<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/69670366">GCC Inline Assembly HOWTO[译]</a>，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://linux.cn/article-7688-1.html">GCC 内联汇编 HOWTO</a>，但感觉翻的不够好，大多地方都是机翻。</p>
<hr>
<h1>引言</h1>
<h2 id="版权与协议">版权与协议</h2>
<p>Copyright ©2003 Sandeep S.</p>
<p>本文是免费的，你可以根据自由软件基金会发布的 GNU 通用公共许可证（GPL v2.0 或由你选择的后续版本）的条款重新发布或修改它。</p>
<p>分发此文档是希望它有用，但不作任何保证；甚至没有对适销性或针对特定目的的适用性的暗示保证。有关更多详细信息，请参阅 GNU 通用公共许可证。</p>
<h2 id="反馈与更正">反馈与更正</h2>
<p>请将反馈意见和批评意见发给 <a href="busybox@sancharnet.in">Sandeep.S</a>。对于指出这份文档中的错误和不准确之处的人我会心怀感激之情；一旦接到通知我将马上改正。</p>
<h2 id="鸣谢">鸣谢</h2>
<p>我真诚地感谢 GNU 的人们提供了如此伟大的特性。感谢 Pramode C E 先生的帮助。感谢政府工程学院的朋友们，感谢他们道义上的支持和合作，特别是 Nisha Kurur 和 Sakeeb s。感谢我亲爱的政府工程学院老师们的合作。</p>
<p>此外，感谢 Phillip, Brennan Underwood 和 <a href="mailto:colin@nyx.net" rel="external nofollow noreferrer">colin@nyx.net</a>，这里的许多东西都是从他们的作品中偷来的。</p>
<h1>概述</h1>
<p>我们在这里学习 GCC 内联汇编，那么什么是内联汇编？</p>
<p>我们可以指示编译器，在调用一个函数时，让被调用的整个函数代码插入到调用它的函数中，这种（被调用的）函数称为内联函数。听起来和 C 语言中的<strong>宏定义</strong>类似。</p>
<p>内联函数有什么优点呢？</p>
<p>这种内联方法减少了函数调用的开销。如果任何实参是常量，它们的已知值可能允许在编译时进行简化，因此不需要包含所有内联函数的代码。对代码大小的影响是未知的，这要具体情况具体分析。要声明内联函数，我们必须在声明中使用关键字 <code>inline</code>。</p>
<p>现在我们可以猜测什么是内联汇编了。它只是一些编写为内联函数的汇编<strong>程序</strong>。它们方便，快速，在系统编程时非常有用。我们关注的重点是（GCC）内联汇编函数的基本格式和用法。</p>
<p>内联汇编之所以重要，主要是因为它操作 C 语言变量并使其可见的能力。由于这种能力，<code>asm</code> 用作汇编指令和包含它的 C 语言程序之间的接口。</p>
<h1>GCC 汇编语法</h1>
<p>GCC 是 Linux 下的 GNU C 语言编译器，使用 AT&amp;T/UNIX 汇编语法。我们也将使用该语法来编写代码。如果你对 AT&amp;T 语法不熟悉也别担心，我会教你。我将给出它与 Intel 语法不同之处。</p>
<ol>
<li>源操作数-目的操作数赋值方向</li>
</ol>
<p>AT&amp;T 语法中操作数的方向与 Intel 语法相反。在 Intel 语法中，第一个是目的操作数，第二个是源操作数，而在 AT&amp;T 语法中，情况相反。也就是说</p>
<p><code>操作 目的 源</code> 是 Intel 的语法，而</p>
<p><code>操作 源 目的</code> 是 AT&amp;T 语法。</p>
<ol start="2">
<li>寄存器名称</li>
</ol>
<p>寄存器名称需要添加前缀 <code>%</code>。例如，如果使用 <code>eax</code> 寄存器需要写成 <code>%eax</code>。</p>
<ol start="3">
<li>操作立即数</li>
</ol>
<p>AT&amp;T 对立即数的操作需要添加 <code>$</code>。对于 C 语言的静态变量，使用的也是 <code>$</code> 作前缀（译者注：不清楚这是GCC的什么语法）。在 Intel 语法里，十六进制数用 <code>h</code> 作为后缀，AT&amp;T 使用 <code>0x</code> 前缀来表示十六进制数。因此对于十六进制数，我们首先看到的是 <code>$</code>，然后是 <code>0x</code>，最后是数字本身。</p>
<ol start="4">
<li>操作数大小</li>
</ol>
<p>在 AT&amp;T 语法中，操作数的大小由操作码的最后一个字符决定。操作码的后缀 <code>b</code>，<code>w</code>和<code>l</code>分别代表一个字节（8 bit），一个字（16 bit）和一个双字（32 bit）（译者注：一个四字（64 bit）用<code>q</code> 表示）。Intel 语法通过在操作数（不是操作码）前面加上 <code>byte ptr</code>, <code>word ptr</code> 和 <code>dword ptr</code> 来实现这一点。</p>
<p>因此，对于 Intel 语法下的指令 <code>mov al, byte ptr foo</code> 在 AT&amp;T 下为 <code>movb foo, %al</code>。</p>
<ol start="5">
<li>内存操作数</li>
</ol>
<p>在 Intel 语法中，寄存器使用左右中括号括起来的，而在 AT&amp;T 语法中，变成了左右小括号，此外，在 Intel 语法中间接内存引用是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">section:</span><br><span class="line">  [base + index*scale + disp]</span><br></pre></td></tr></table></figure>
<p>在 AT&amp;T 中变成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">section:</span><br><span class="line">  disp(base,index,scale)</span><br></pre></td></tr></table></figure>
<p>需要记住的一点是，当 <code>disp/scale</code> 使用一个常量时，不应该加 <code>$</code> 前缀。</p>
<p>现在我们看到了 Intel 语法和 AT&amp;T 语法之间的一些主要差异。我只写了其中的一些。要获得完整的信息，请参考 GNU Assembler 文档。为了更好地理解，现在我们来看一些例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">|       Intel Code             |      AT&amp;T Code                     |</span><br><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">| mov     eax,1                |  movl    $1,%eax                   |   </span><br><span class="line">| mov     ebx,0ffh             |  movl    $0xff,%ebx                |   </span><br><span class="line">| int     80h                  |  int     $0x80                     |   </span><br><span class="line">| mov     ebx, eax             |  movl    %eax, %ebx                |</span><br><span class="line">| mov     eax,[ecx]            |  movl    (%ecx),%eax               |</span><br><span class="line">| mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              | </span><br><span class="line">| mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |</span><br><span class="line">| add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |</span><br><span class="line">| lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |</span><br><span class="line">| sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |</span><br><span class="line">+------------------------------+------------------------------------+</span><br></pre></td></tr></table></figure>
<p>译者注：田宇的《一个64位操作系统的设计与实现》中将两者之间的主要差异总结成了下面的表格：</p>
<p><img src="https://lushuangning.oss-cn-beijing.aliyuncs.com/image/202109241.png" alt=""></p>
<h1>基本内联</h1>
<p>基本内联的格式非常直接，形如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;assembly code&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>);  <span class="comment">/* moves the contents of ecx to eax */</span></span><br><span class="line">__asm__(<span class="string">&quot;movb %bh (%eax)&quot;</span>); <span class="comment">/*moves the byte from bh to the memory pointed by eax */</span></span><br></pre></td></tr></table></figure>
<p>可能你注意到了我这里用了 <code>asm</code> 和 <code>__asm__</code>，二者是等价的。如果我们的程序与关键字 <code>asm</code> 与冲突了可以用 <code>__asm__</code> 来代替。如果有多个指令，则每行写一条，用双引号引起来，并在指令后面加上 <code>\t</code> 和 <code>\n</code> 后缀。这是因为 GCC 将每个指令作为字符串发送给 as(GAS)，通过使用换行符或制表符，我们将正确格式化的行发送给汇编器。</p>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm__ (<span class="string">&quot;movl %eax, %ebx\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movl $56, %esi\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movl %ecx, $label(%edx,%ebx,$4)\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movb %ah, (%ebx)&quot;</span></span><br><span class="line">         );</span><br></pre></td></tr></table></figure>
<p>在我们的代码中，如果我们影响了(例如，更改内容)一些寄存器的值，而没有在汇编返回前修复这些更改，那么就会发生不好的事情。这是因为 GCC 不知道寄存器内容的变化，这就给我们带来了麻烦，特别是当编译器对代码进行优化的时候。它将假设某个寄存器包含某个变量的值，而我们可能在没有通知 GCC 的情况下更改了变量的值，GCC 将无视这些变化。我们所能做的是，要么使用那么没有副作用的指令，要么在我们退出的时候修复这些更改，要么，我们就等它崩溃好了。这就是我们想扩展一些功能的地方。扩展汇编为我们提供了这种功能。</p>
<h1>扩展内联汇编</h1>
<p>基本内联汇编中，我们只有指令。在扩展汇编中，我们还可以指定操作数。这允许我们指定输入的寄存器，输出的寄存器和被破坏的寄存器列表（clobber 列表：如果内联汇编代码使用了没有被初始化地声明为输入值或者输出值的任何其他寄存器，则要通知编译器，编译器必须知道这些寄存器，避免使用它们）。指定要使用的寄存器并不是强制要求的，我们可以把这个难题留给 GCC 来解决，这可能更适合 GCC 的优化方案。扩展内联汇编的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( assembler <span class="keyword">template</span> </span><br><span class="line">    : output operands                  <span class="comment">/* optional */</span></span><br><span class="line">    : input operands                   <span class="comment">/* optional */</span></span><br><span class="line">    : list of clobbered registers      <span class="comment">/* optional */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>assembler template 由汇编指令组成。每个操作数都由一个操作数约束字符来描述，后面跟 C 语言表达式（圆括号括起来）。第一个冒号将 assembler template 与第一个输出操作数分隔开，第二个冒号将最后一个输出操作数与第一个输入操作数（如果有的话）分开。逗号分隔每个组内的操作数。操作数的总数限制为 10，或者汇编描述中的任何指令格式中的最大操作数数目，以较大者为准。</p>
<p>如果没有输出操作数但有输入操作数，那么也需要有一个冒号放在输出操作数的位置。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( <span class="string">&quot;cld\n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;rep\n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;stosl&quot;</span></span><br><span class="line">      : <span class="comment">/* no output registers */</span></span><br><span class="line">      : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest)</span><br><span class="line">      : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%edi&quot;</span> </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>上面的代码做了什么事呢？上面的内联代码把 <code>fill_value</code> 乘以 <code>count</code> 的值填充到 <code>%edi</code> 寄存器里。它还告诉 GCC，寄存器 <code>%eax</code> 和 <code>%edi</code> 的内容发生了变化。再来看一个更清楚的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">      :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">      :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">      :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">    );    </span><br></pre></td></tr></table></figure>
<p>这段代码所做的就是使 ‘b’ 变量的值等于 ‘a’ 变量的值。一些有意思的地方是：</p>
<ul>
<li>“b” 作为输出操作数，用 %0 引用，“a” 作为输入操作数，用 %1 引用</li>
<li>“r” 为操作数约束。之后我们会更详细地了解约束。目前，“r” 告诉 GCC 可以使用任意寄存器存储操作数。输出操作数约束有一个约束修饰符 “=”，这表明它是一个只读的输出操作数。</li>
<li>寄存器名字用两个 “%” 作前缀，这有利于 GCC 区分操作数和寄存器。操作数用一个 “%” 作前缀。</li>
<li>第三个冒号之后的 clobbered 寄存器 <code>%eax</code> 用于告诉 GCC它的值将会在内联汇编阶段被修改，所以 GCC 将不会使用此寄存器存储任何其他值。</li>
</ul>
<p>当内联汇编执行完毕后，“b” 变量将会映射到新的值，因为它被指定为输出操作数。换句话说，内联汇编内部 “b” 变量的修改会被映射到内联汇编的外部。</p>
<p>现在让我们详细地看看每个部分的细节。</p>
<h2 id="汇编程序模板">汇编程序模板</h2>
<p>汇编程序模板包含了被插入到 C 程序的汇编指令集。其格式为：每条指令用双引号引起，或者整个指令组用双引号引起。同时每条指令应以分界符结尾。有效的分界符有换行符（<code>\n</code>）和分号（<code>;</code>）。<code>\n</code>可以紧随一个制表符（<code>\t</code>）。我们应该都明白使用换行符或制表符的原因了吧（译注：前面已有说明）。和C语言表达式对应的操作数用 %0、%1 … 等等表示。</p>
<h2 id="操作数">操作数</h2>
<p>C 语言表达式用作内联汇编指令里的操作数。每个操作数的前面以双引号引起的是操作数约束。对于输出操作数，在引号内还有一个约束修饰符。其后紧随一个用于表示操作数的 C 表达式。</p>
<p>即，<code>“操作数约束”（C表达式）</code> 是一个通用格式。对于输出操作数，还有一个额外的修饰符。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。</p>
<p>如果我们使用多个操作数，它们之间应该用逗号隔开。</p>
<p>在汇编程序模板中，每个操作数用数字来引用。编号方式如下：如果总共有 n 个操作数（包括输入和输出操作数），那么第一个输出操作数编号为 0，逐项递增，并且最后一个输入操作数编号为 n-1。操作数的最大数目我们前一节已经讲过。</p>
<p>输出操作数表达式必须为左值。输入操作数的要求不这么严格，它们可以为表达式。扩展汇编的特性常常用于编译器所不知道的机器指令。如果输出的表达式无法直接寻址（例如，它是一个位域），我们的约束字符串必须给定一个寄存器。在这种情况下，GCC 将会使用该寄存器存储最终的结果，然后把该寄存器的值输出。</p>
<p>如前文所述，普通的输出操作数必须为“只写”的。GCC 将会假设指令前的操作数值是死的，不需要（提前）生成。扩展汇编也支持输入-输出，或者读-写操作数。</p>
<p>所以现在我们来关注一些实例。我们想要求一个数乘以5的结果，为了计算该值，我们使用 <code>lea</code> 指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( <span class="string">&quot;leal (%1,%1,4), %0;&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">      : <span class="string">&quot;r&quot;</span> (x) </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>这里，我们的输入为 <code>x</code>。我们不指定使用的寄存器。GCC 将会选择一些寄存器作为输入和输出的寄存器。如果我们想要输入和输出放在同一个寄存器里，我们可以指定寄存器这样做。这里我们使用读-写操作，通过合适的约束来实现它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( <span class="string">&quot;leal (%0,%0,4), %0;&quot;</span></span><br><span class="line">      : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">      : <span class="string">&quot;0&quot;</span> (x) </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>现在输出和输入操作数位于同一个寄存器。但是我们无法得知是哪一个寄存器。现在假如我们也想指定操作数所在的寄存器，这里有一种方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> ( <span class="string">&quot;leal (%%ecx,%%ecx,4), %%ecx;&quot;</span></span><br><span class="line">      : <span class="string">&quot;=c&quot;</span> (x)</span><br><span class="line">      : <span class="string">&quot;c&quot;</span> (x) </span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>在以上三个示例中，我们并没有往 clobber 列表中添加任何寄存器，为什么呢？前两个示例，GCC 自己决定使用哪个寄存器，所以它知道哪些寄存器会发生改变。在最后一个示例中，我们不必将 <code>ecx</code> 添加到 clobber 列表中，GCC 知道它表示 x。因此，因为它可以知道 <code>ecx</code> 的值，他就不被当作 clobber 了。</p>
<h2 id="Clobber-列表">Clobber 列表</h2>
<p>一些指令会破坏一些寄存器的内容。我们不得不在 clobber 列表中指明这些被修改的寄存器，即扩展内联汇编中第三个 <code>:</code> 之后的区域。这可以通知 GCC “我们自己使用和修改了这些寄存器”，这样GCC 就不会假设存入这些寄存器的值是有效的了。我们不应在这个列表里列出输入、输出寄存器，因为 GCC 知道这些汇编使用了它们（因为它们被约束显示地指定了）。如果指令隐式或显式地使用了任何其他寄存器（并且寄存器没有出现在输如或者输出的约束列表里），那么就需要在 clobber 列表中指定这些寄存器。</p>
<p>如果我们的指令可以修改条件码寄存器（cc），我们必须将 <code>cc</code> 添加到 clobber 列表。</p>
<p>如果我们的指令以不可预测的方式修改了内存，那么需要将 <code>memory</code> 添加到 clobber 列表。这可以使 GCC 在整个汇编指令中不保存缓存在寄存器中的内存值。如果汇编的输入或输出中没有列出受影响的内存，我们还必须添加 <code>volatile</code> 关键字。</p>
<p>我们可以按我们的需求多次读写 clobber 列表中的寄存器。参考一下模板内多条指令的示例，它假设子函数 _foo 把寄存器 eax 和 ecx 中的的值当作自己的参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %0,%%eax;</span></span><br><span class="line"><span class="string">      movl %1,%%ecx;</span></span><br><span class="line"><span class="string">      call _foo;&quot;</span></span><br><span class="line">      : <span class="comment">/* no outputs */</span></span><br><span class="line">      : <span class="string">&quot;g&quot;</span> (from), <span class="string">&quot;g&quot;</span> (to)</span><br><span class="line">      : <span class="string">&quot;eax&quot;</span>, <span class="string">&quot;ecx&quot;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h2 id="5-4-Volatile-…">5.4 Volatile … ?</h2>
<p>如果你对内核源码比较熟悉，或者看过类似的很棒的代码，你一定见过许多声明为 <code>volatile</code> 或者 <code>__volatile__</code> 的函数，其后跟着一个 <code>asm</code> 或者 <code>__asm__</code>。我前面提到过关键字 <code>asm</code> 和 <code>__asm__</code>，那什么是 <code>volatile</code> 呢？</p>
<p>如果我们的汇编语句必须再我们放置它的地方执行（例如，不能为了优化而把它移出循环），那么把关键字 <code>volatile</code> 放在 <code>asm</code> 之后，<code>()</code> 之前，以防止它被移动、被删除或者其他操作。我们将其声明为 <code>asm volatile (... : ... : ... : ...);</code>。</p>
<p>如果担心关键字冲突，可以使用 <code>__volatile__</code>。</p>
<p>如果我们的汇编语句只是用于一些简单的计算，那就最好不要使用 <code>volatile</code>。不使用的话 GCC 会把代码优化得更漂亮。</p>
<p>在第7节中，我提供了多个内联汇编的例子。在那里可以了解到 clobber 列表的细节。</p>
<h1>关于约束</h1>
<p>到目前为止，你可能已经知道了约束与内联汇编之间有很大的联系。但是我们对约束讲的不多。约束用于表明一个操作数是否在寄存器中，以及寄存器的类型；操作数是否是一个内存引用以及地址的类型；操作数是否可能是一个立即数，它可能有哪些值（即取值的范围），等等。</p>
<h2 id="常用约束">常用约束</h2>
<p>在许多的约束中，只有一小部分是比较常用的，我们来看看这些约束。</p>
<ol>
<li>寄存器操作数约束（r）</li>
</ol>
<p>当使用这种约束指定操作数时，它们存储在通用寄存器中（GPR）。请看下面的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %%eax,%0;&quot;</span> :<span class="string">&quot;=r&quot;</span>(myval));</span><br></pre></td></tr></table></figure>
<p>这里，变量 <code>myval</code> 保存在寄存器中，寄存器 <code>eax</code> 里的值被复制到该寄存器中，并且 <code>myval</code> 的值从寄存器更新到了内存。当指定为 “r” 约束时，GCC 可以将变量保存在任何可用的 GPR 中。要指定寄存器，你必须使用特定的寄存器约束直接指定寄存器名。它们是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+--------------------+</span><br><span class="line">| r |    <span class="built_in">Register</span>(s)     |</span><br><span class="line">+---+--------------------+</span><br><span class="line">| a |   %eax, %ax, %al   |</span><br><span class="line">| b |   %ebx, %bx, %bl   |</span><br><span class="line">| c |   %ecx, %cx, %cl   |</span><br><span class="line">| d |   %edx, %dx, %dl   |</span><br><span class="line">| S |   %esi, %si        |</span><br><span class="line">| D |   %edi, %di        |</span><br><span class="line">+---+--------------------+</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>内存操作数约束（m）</li>
</ol>
<p>当操作数位于内存时，对它们执行的任何操作都将直接发生在内存位置，这与寄存器约束不同，寄存器约束首先将值存储在要修改的寄存器中，然后将其写回内存位置。但是寄存器约束通常用于指令必须使用它们，或者使用它们可以显著提高处理速度的情况下使用。当需要在 asm 内更新一个 C 变量，而又不想使用寄存器去保存它的值，使用内存约束是最有效的。例如，idtr 的值存储在内存 loc 处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;sidt %0;&quot;</span> : :<span class="string">&quot;m&quot;</span>(loc));  # 译者注： sidt 指令用于保存中断描述符</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>匹配（数字）约束</li>
</ol>
<p>在某些情况下，一个变量可能既是输入操作数，也是输出操作数。这种情况可以通过匹配约束在 asm 中指定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;incl %0;&quot;</span> :<span class="string">&quot;=a&quot;</span>(var):<span class="string">&quot;0&quot;</span>(var));</span><br></pre></td></tr></table></figure>
<p>在操作数一节中，我们也看到了一些类似的示例。在这个匹配约束的示例中，寄存器 <code>%eax</code> 既用作输入变量，也用作输出变量。var 作为输入被读到 <code>%eax</code>，更新后的 <code>%eax</code> 再次存储在 var 中。这里的 “0”用于指定与第 0 个输出变量相同的约束。也就是说，它指定 var 的输出实例应该只存储在 <code>%eax</code> 中。该约束可用于：</p>
<ul>
<li>从一个变量读取输入，或修改变量，并将修改写回相同的变量的情况。</li>
<li>在不需要将输入操作数实例和输出操作数实例分开的情况。</li>
</ul>
<p>使用匹配约束最重要的意义在于，它们可以有效地使用寄存器。</p>
<p>其他一些约束：</p>
<p>1). “m”：允许一个内存操作数，可以使用硬件支持的任意寻址方式。<br>
2). “o”：允许一个内存操作数，但寻址方式是可偏移的。即，该地址加上一个小的偏移量可以得到一个有效的地址。<br>
3). “V”：一个不允许偏移的内存操作数。即，任何适合 “m” 约束而不适合 “o” 约束的操作数。<br>
4). “i”：允许一个（带有常量）立即整型操作数。这包括只有在汇编时才知道其值的符号常量。<br>
5). “n”：允许具有已知数值的直接整数操作数。许多系统不能为小于一个字宽的操作数支持汇编时常量。这些操作数的约束应该使用 “n” 而不是 “i”。<br>
6). “g”:允许任何寄存器、内存或者立即数操作数，但不包括通用寄存器之外的寄存器。</p>
<p>以下约束为 x86 特有：</p>
<p>1.) “r”： 寄存器操作数约束，查阅上面给的表格<br>
2.) “q”：寄存器 a、b、c 或 d<br>
3.) “I”：范围从 0 到 31 的常量（对于32位移位）<br>
4.) “J”：范围从 0 到 63 的常量（对于64位移位）<br>
5.) “K”：0xff<br>
6.) “L”：0xffff<br>
7.) “M”：0、1、2 或 3 （lea 指令的移位）<br>
8.) “N”：范围从 0 到 255 的常量（对于 out 指令）<br>
9.) “f”：浮点寄存器<br>
10.) “t”：第一个（栈顶）浮点寄存器<br>
11.) “u”：第二个浮点寄存器<br>
12.) “A”：指定 <code>a</code> 或 <code>d</code> 寄存器。这主要用于想要返回 64 位整数值，<code>d</code> 寄存器包含最高的有效位，<code>a</code> 寄存器包含最低的有效位</p>
<h2 id="约束修饰符">约束修饰符</h2>
<p>当使用约束时，对于更精确地控制约束的效果，GCC 为我们提供了约束修饰符。最常用的约束修饰符为：</p>
<ol>
<li>“=”： 这个操作数对这条指令来说是只写的，之前的值将被丢弃，并被输出的数据替换</li>
<li>“&amp;”：这个操作数是一个早期改动的操作数，它在使用输入操作数完成指令之前被修改。因此，这个操作数不能位于一个被用作输入操作数或任何内存地址部分的寄存器中。如果在旧值被写入之前它仅用作输入，那么它可以是一个早期改动的操作数。</li>
</ol>
<p>上述的约束列表和解释并不完整。接下来的示例可以让我们更好的理解内联汇编的用途和用法。在下一节中，我们会看到一些示例，在那里我们会发现更多关于 clobber-list 和约束的东西。</p>
<h1>一些实用的诀窍</h1>
<p>我们已经介绍了关于 GCC 内联汇编的基础理论，现在我们专注于一些简单的例子。将内联汇编函数写成宏的形式总是很方便的。我们可以在 Linux 内核代码里看到许多汇编函数（/usr/src/linux/include/asm/*.h）。</p>
<ol>
<li>首先我们从一个简单的例子入手。看下面这个两个数相加的程序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> foo = <span class="number">10</span>, bar = <span class="number">15</span>;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;addl %%ebx, %%eax;&quot;</span></span><br><span class="line">                        : <span class="string">&quot;=a&quot;</span>(foo)</span><br><span class="line">                        : <span class="string">&quot;a&quot;</span>(foo), <span class="string">&quot;b&quot;</span>(bar)</span><br><span class="line">                        );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo + bar = %d\n&quot;</span>, foo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们要求 GCC 将 foo 存放于 <code>%eax</code>，将 bar 存放于 <code>%ebx</code>，同时我们也想要在 <code>%eax</code> 中存放结果。 ‘=’ 符号表示它是一个输出寄存器。现在我们可以以其他方式给变量添加一个整数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;lock;&quot;</span></span><br><span class="line">                    <span class="string">&quot;addl %1, %0;&quot;</span></span><br><span class="line">                    : <span class="string">&quot;=m&quot;</span>(my_var)</span><br><span class="line">                    : <span class="string">&quot;ir&quot;</span>(my_int), <span class="string">&quot;m&quot;</span>(my_var)</span><br><span class="line">                    : <span class="comment">/* no clobber-list */</span></span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>
<p>这是一个原子加法。我们可以通过移除指令 “lock” 来移除其原子性。在输出字段中，“=m” 表明 my_var 是一个输出，且位于内存。类似地，“ir” 表明 my_int 是一个整型，应该保存在某个寄存器中（回想下我们上边列的表）。这个里面没有寄存器位于 clobber-list 中。</p>
<ol start="2">
<li>现在我们将在一些寄存器或变量上展示一些操作，并比较值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;decl %0;&quot;</span></span><br><span class="line">                    <span class="string">&quot;sete %1;&quot;</span></span><br><span class="line">                    : <span class="string">&quot;=m&quot;</span>(my_var), <span class="string">&quot;=q&quot;</span>(cond)</span><br><span class="line">                    : <span class="string">&quot;m&quot;</span>(my_var)</span><br><span class="line">                    : <span class="string">&quot;memory&quot;</span></span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>
<p>这里 my_var 的值减 1，并且如果结果的值为 0，则变量 cond 置 1。我们可以通过将指令 <code>lock;\n\t</code> 添加到内联汇编模板的第一条指令以增加其原子性。</p>
<p>同样地，为了使 my_var 的值加1，我们可以使用 <code>incl %0</code> 来代替 <code>decl %0</code>。</p>
<p>这里需要注意的是，(1) my_var 是一个存储于内存的变量；(2) cond 位于寄存器 %eax、%ebx、%ecx、%edx 中的任意一个（约束 “=q” 保证了这一点）；(3) memory 位于 clobber-list 中，也就是说，这段代码将改变内存中的内容。</p>
<ol start="3">
<li>如何置 1 或清 0 寄存器中的一个比特位？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(<span class="string">&quot;btsl %1, %0;&quot;</span></span><br><span class="line">                    : <span class="string">&quot;=m&quot;</span>(ADDR)</span><br><span class="line">                    : <span class="string">&quot;Ir&quot;</span>(pos)</span><br><span class="line">                    : <span class="string">&quot;cc&quot;</span></span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>
<p>这里，ADDR 变量（一个内存变量）的第 pos 位上被置为 1。我们可以使用 <code>btrl</code> 来清除由 <code>btsl</code> 设置的比特位。pos 的约束 “Ir” 表明 pos 位于寄存器，并且它的值为 0-31 （x86 相关约束）。也就是说，我们可以设置或清除 ADDR 变量上第 0-31 位的任意位。由于条件码会被改变，所以我们将 “cc” 添加到 clobber-list。</p>
<ol start="4">
<li>现在我们看一些更为复杂但有用的函数。字符串拷贝</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> d0, d1, d2;</span><br><span class="line">	<span class="comment">// lodsb:取字节，将esi指向的地址中的数据取出来赋给al寄存器，esi=esi+1</span></span><br><span class="line">	<span class="comment">// stosb:取字节，将al寄存器的值取出来赋给edi指向的地址，edi=edi+1</span></span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;1: lodsb;&quot;</span>  <span class="comment">// 这里的&quot;1:&quot;是个label，下面的jne 1b可跳转到此处</span></span><br><span class="line">        <span class="string">&quot;stosb;&quot;</span></span><br><span class="line">        <span class="string">&quot;testb %%al,%%al;&quot;</span></span><br><span class="line">        <span class="string">&quot;jne 1b;&quot;</span></span><br><span class="line">        : <span class="string">&quot;=&amp;S&quot;</span>(d0), <span class="string">&quot;=&amp;D&quot;</span>(d1), <span class="string">&quot;=&amp;a&quot;</span>(d2)</span><br><span class="line">        : <span class="string">&quot;0&quot;</span>(src), <span class="string">&quot;1&quot;</span>(dest)</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dest 存放于 edi，src 存放于 esi。当到达字符串末尾（“0”）时，拷贝完成。约束 “&amp;S”，“&amp;D”，“&amp;a”表明 esi, edi 和 eax 是早期 clobber 的寄存器。也就是说，它们的内容在函数完成前会被改变。这里很明显 memory 被放进了 clobber-list里。</p>
<p>我们可以看到一个类似的函数，它能移动一个双字的数据。注意，函数被声明成一个宏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mov_blk(src, dest, numwords)        \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__(                       \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;cld;&quot;</span>                                  \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;rep;&quot;</span>                                  \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movsl;&quot;</span>                                \</span></span><br><span class="line"><span class="meta">    :                                       \</span></span><br><span class="line"><span class="meta">    : <span class="string">&quot;S&quot;</span>(src),<span class="string">&quot;D&quot;</span>(dest), <span class="string">&quot;c&quot;</span>(numwords)     \</span></span><br><span class="line"><span class="meta">    : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%esi&quot;</span>, <span class="string">&quot;%edi&quot;</span>                \</span></span><br><span class="line"><span class="meta">);</span></span><br></pre></td></tr></table></figure>
<p>这里我们没有输出，寄存器 ecx、esi 和 edi 的内容发生了改变，这是块移动的副作用。因此我们必须将它们添加进 clobber-list。、</p>
<ol start="5">
<li>在 Linux 中，系统调用使用 GCC 内联汇编实现。让我们看看如何实现一个系统调用。所有的系统调用被写成宏（linux/unistd.h）。例如，带有三个参数的系统调用被定义为如下所示的宏。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)&#123;   \</span></span><br><span class="line"><span class="meta">    long __res;                                                         \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__(                                               \</span></span><br><span class="line"><span class="meta">        <span class="string">&quot;int $0x80;&quot;</span>                                                    \</span></span><br><span class="line"><span class="meta">        : <span class="string">&quot;=a&quot;</span>(__res)                                                   \</span></span><br><span class="line"><span class="meta">        : <span class="string">&quot;0&quot;</span>(__NR_##name), <span class="string">&quot;b&quot;</span>((long)(arg1)), <span class="string">&quot;c&quot;</span>((long)(arg2)),       \</span></span><br><span class="line"><span class="meta">        <span class="string">&quot;d&quot;</span>((long)(arg3))                                               \</span></span><br><span class="line"><span class="meta">    );                                                                  \</span></span><br><span class="line"><span class="meta">__syscall_return(type, __res);                                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>每当进行带有三个参数的系统调用时，都会使用上面所示的宏进行系统调用。系统调用编号放在 eax 中，参数分别位于 ebx、ecx、edx 中。<code>int 0x80</code> 是一条用于执行系统调用的指令。返回值存储在 eax 中。</p>
<p>每个系统调用都以类似的方式实现。exit 是仅有一个参数的系统调用，它的代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;movl $1, %%eax;&quot;</span>       <span class="comment">/* SYS_exit is 1 */</span></span><br><span class="line">        <span class="string">&quot;xorl %%ebx,%%ebx;&quot;</span>     <span class="comment">/* Argument is in ebx, it is 0 */</span></span><br><span class="line">        <span class="string">&quot;int $0x80;&quot;</span>            <span class="comment">/* Enter kernel mode */</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exit 的系统调用编号是 “1”，同时它的参数是 “0”。因此我们把 eax 的值设置为 1，ebx 的值设置为 0，通过 <code>int $0x80</code> 指令就可以执行 <code>exit(0)</code>。这就是 exit 的工作原理。</p>
<h1>结束语</h1>
<p>本文档介绍了 GCC 内联汇编的基本知识。一旦你理解了这个基本概念，你就可以按照自己的需求去使用它了。我们看到了一些示例，它们有助于理解 GCC 内联汇编的常用特性。</p>
<p>GCC 内联是一个庞大的主题，本文是不完整的。我们所讨论的语法的更多细节可以在 GNU Assembler 的官方文档中找到。类似地，要获得约束的完整列表，请参阅 GCC 的官方文档。</p>
<p>当然，Linux 内核大规模地使用 GCC 内联。因此，我们可以在内核源代码中找到各种各样的例子。他们可以帮助我们很多。</p>
<p>如果您在本文档中发现任何明显的错别字或过时的信息，请告诉我们。</p>
<h1>参考</h1>
<ol>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">Brennan’s Guide to Inline Assembly</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://linuxassembly.org/articles/linasm.html">Using Assembly Language in Linux</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.gnu.org/manual/gas-2.9.1/html_mono/as.html">Using as, The GNU Assembler</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://gcc.gnu.org/onlinedocs/gcc_toc.html">Using and Porting the GNU Compiler Collection (GCC)</a></li>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="http://ftp.kernel.org/">Linux Kernel Source</a></li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lushuangning.github.io">路双宁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lushuangning.github.io/posts/6413021f/">https://lushuangning.github.io/posts/6413021f/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本文开放转载，请根据 GNU General Public License 转载和修改</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/b895802c/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">STL各容器的基本操作</div></div></a></div><div class="next-post pull-right"><a href="/posts/9eba23ca/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">站在巨人的肩上之操作系统篇（三）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2024 By 路双宁</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    const initData = {
      el: '#vcomment',
      appId: 'VMqnI9pLmxxHTgJswVD4NG7b-gzGzoHsz',
      appKey: 'IIEWxiiBotI5HSnW0J416lsU',
      placeholder: '快来评论吧',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }

    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="aplayer no-destroy" data-id="003B4aet4U1Flz" data-server="tencent" data-type="song" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  $('script[data-pjax]').each(function () {
    $(this).parent().append($(this).remove())
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  $(window).off('scroll')

  //reset readmode
  $('body').hasClass('read-mode') && $('body').removeClass('read-mode')

})</script></div></body></html>